<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HTML5 Car Racing Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
  />
  <style>
    #gameCanvas {
      border: 4px solid #1f2937; 
      border-radius: 0.5rem;
      background-color: #111827; 
      display: block;
      margin: 0 auto;
      /* --- NEW: Make canvas responsive --- */
      max-width: 100%; /* Ensures canvas doesn't overflow its container */
      height: auto; /* Maintains aspect ratio */
    } 
    .back-button {
      position: absolute;
      top: 10px;
      left: 10px;
      text-decoration: none;
      background-color: #7f8c8d;
      color: white;
      padding: 8px 15px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 100;
    }
    .back-button:hover {
      background-color: #95a5a6;
    }

    /* --- NEW: Improve layout on small screens --- */
    @media (max-width: 640px) {
      .controls-container {
        flex-direction: column;
      }
      .instructions {
        font-size: 0.875rem; /* Make text slightly smaller */
      }
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col min-h-screen">
  <a href="../../index.html" class="back-button">‚Üê Back to Menu</a>

  <header class="bg-gray-800 p-4 shadow-md">
    <h1 class="text-3xl font-bold text-center font-sans">HTML5 Car Racing Game</h1>
  </header>

  <main class="flex-grow flex flex-col items-center justify-center p-4">
    <canvas
      id="gameCanvas"
      width="400"
      height="600"
      aria-label="Car racing game canvas"
      role="img"
    ></canvas>

    <div class="mt-6 flex flex-col sm:flex-row gap-4 items-center controls-container">
      <button
        id="startBtn"
        class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-6 rounded shadow focus:outline-none focus:ring-2 focus:ring-green-400 flex items-center gap-2"
      >
        <i class="fas fa-play"></i> Start
      </button>
      <button
        id="pauseBtn"
        class="bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-semibold py-2 px-6 rounded shadow focus:outline-none focus:ring-2 focus:ring-yellow-300 flex items-center gap-2"
        disabled
      >
        <i class="fas fa-pause"></i> Pause
      </button>
      <button
        id="resetBtn"
        class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-6 rounded shadow focus:outline-none focus:ring-2 focus:ring-red-400 flex items-center gap-2"
        disabled
      >
        <i class="fas fa-redo"></i> Reset
      </button>
    </div>

    <div class="mt-6 text-center text-lg font-mono">
      <p>Score: <span id="score">0</span></p>
      <p>Speed: <span id="speed">5</span></p>
    </div>

    <div class="mt-6 max-w-md text-center text-gray-400 font-sans instructions">
      <p id="instructions-text">Use Arrow Keys, A/D, or Tap the screen sides to move.</p>
    </div>
  </main>

  <footer class="bg-gray-800 p-4 text-center text-gray-400 text-sm">
    &copy; 2024 Car Racing Game. All rights reserved.
  </footer>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const roadWidth = 200;
    const laneCount = 3;
    const laneWidth = roadWidth / laneCount;
    const roadLeft = (canvas.width - roadWidth) / 2;

    let animationId;
    let gameRunning = false;
    let score = 0;
    let speed = 5;
    let speedIncrementInterval;
    let enemySpawnInterval;

    const playerCar = {
      width: 40,
      height: 80,
      x: roadLeft + laneWidth * 1 + laneWidth / 2 - 20,
      y: canvas.height - 100,
      lane: 1,
      color: "#3b82f6",
    };

    const enemies = [];

    const playerCarImg = new Image();
    playerCarImg.src = "https://ik.imagekit.io/uwuohiivl/cars/games/main_car.png?text=Car";

    const enemyCarImgs = [
      "https://ik.imagekit.io/uwuohiivl/cars/games/car1.png?text=Enemy1",
      "https://ik.imagekit.io/uwuohiivl/cars/games/car2.png?text=Enemy2",
      "https://ik.imagekit.io/uwuohiivl/cars/games/car3.png?text=Enemy3",
      "https://ik.imagekit.io/uwuohiivl/cars/games/car4.png?text=Enemy4",
    ].map((src) => {
      const img = new Image();
      img.src = src;
      return img;
    });

    function drawRoad() {
      ctx.fillStyle = "#374151";
      ctx.fillRect(roadLeft, 0, roadWidth, canvas.height);
      ctx.strokeStyle = "#d1d5db";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(roadLeft, 0);
      ctx.lineTo(roadLeft, canvas.height);
      ctx.moveTo(roadLeft + roadWidth, 0);
      ctx.lineTo(roadLeft + roadWidth, canvas.height);
      ctx.stroke();
      ctx.strokeStyle = "#9ca3af";
      ctx.lineWidth = 2;
      ctx.setLineDash([20, 20]);
      for (let i = 1; i < laneCount; i++) {
        const x = roadLeft + laneWidth * i;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    function drawPlayer() {
      ctx.drawImage(playerCarImg, playerCar.x, playerCar.y, playerCar.width, playerCar.height);
    }

    class EnemyCar {
      constructor(lane, speed) {
        this.width = 40;
        this.height = 80;
        this.lane = lane;
        this.x = roadLeft + laneWidth * lane + laneWidth / 2 - this.width / 2;
        this.y = -this.height;
        this.speed = speed;
        this.color = "#ef4444";
        this.img = enemyCarImgs[Math.floor(Math.random() * enemyCarImgs.length)];
      }
      update() { this.y += this.speed; }
      draw() { ctx.drawImage(this.img, this.x, this.y, this.width, this.height); }
    }

    function spawnEnemy() {
      const lane = Math.floor(Math.random() * laneCount);
      const enemy = new EnemyCar(lane, speed);
      enemies.push(enemy);
    }

    function checkCollision(rect1, rect2) {
      return !(
        rect1.x > rect2.x + rect2.width ||
        rect1.x + rect1.width < rect2.x ||
        rect1.y > rect2.y + rect2.height ||
        rect1.y + rect1.height < rect2.y
      );
    }

    function update() {
      if (!gameRunning) return;
      enemies.forEach((enemy, index) => {
        enemy.update();
        if (enemy.y > canvas.height) {
          enemies.splice(index, 1);
          score += 10;
          document.getElementById("score").textContent = score;
        }
      });
      for (const enemy of enemies) {
        if (checkCollision({ ...playerCar }, { ...enemy })) {
          endGame();
          return;
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawRoad();
      drawPlayer();
      enemies.forEach((enemy) => enemy.draw());
    }

    function gameLoop() {
      update();
      draw();
      if (gameRunning) {
        animationId = requestAnimationFrame(gameLoop);
      }
    }

    function startGame() {
      if (gameRunning) return;
      gameRunning = true;
      score = 0;
      speed = 5;
      enemies.length = 0;
      playerCar.lane = 1;
      playerCar.x = roadLeft + laneWidth * 1 + laneWidth / 2 - playerCar.width / 2;
      document.getElementById("score").textContent = score;
      document.getElementById("speed").textContent = speed;
      document.getElementById("startBtn").disabled = true;
      document.getElementById("pauseBtn").disabled = false;
      document.getElementById("resetBtn").disabled = false;
      speedIncrementInterval = setInterval(() => {
        speed += 0.5;
        document.getElementById("speed").textContent = speed.toFixed(1);
      }, 5000);
      enemySpawnInterval = setInterval(spawnEnemy, 1500);
      gameLoop();
    }

    function pauseGame() {
      if (!gameRunning) return;
      gameRunning = false;
      cancelAnimationFrame(animationId);
      clearInterval(speedIncrementInterval);
      clearInterval(enemySpawnInterval);
      document.getElementById("startBtn").disabled = false;
      document.getElementById("pauseBtn").disabled = true;
    }

    function resetGame() {
      pauseGame();
      score = 0;
      speed = 5;
      enemies.length = 0;
      playerCar.lane = 1;
      playerCar.x = roadLeft + laneWidth * 1 + laneWidth / 2 - playerCar.width / 2;
      document.getElementById("score").textContent = score;
      document.getElementById("speed").textContent = speed;
      document.getElementById("resetBtn").disabled = true;
      draw(); // Redraw the reset state
    }

    function endGame() {
      pauseGame();
      // Use a more mobile-friendly confirmation if possible, but alert is universal
      setTimeout(() => {
        alert("Game Over! Your score: " + score);
        resetGame();
      }, 100); // Small delay to let the final frame draw
    }

    function movePlayer(direction) {
      if (!gameRunning) return;
      if (direction === "left" && playerCar.lane > 0) {
        playerCar.lane--;
      } else if (direction === "right" && playerCar.lane < laneCount - 1) {
        playerCar.lane++;
      }
      playerCar.x = roadLeft + laneWidth * playerCar.lane + laneWidth / 2 - playerCar.width / 2;
    }

    // Keyboard controls
    window.addEventListener("keydown", (e) => {
      if (!gameRunning) return;
      if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") {
        movePlayer("left");
      } else if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") {
        movePlayer("right");
      }
    });
    
    // --- NEW: Touch controls ---
    canvas.addEventListener('touchstart', (e) => {
        if (!gameRunning) return;
        
        // Get the position of the canvas on the page
        const rect = canvas.getBoundingClientRect();
        
        // Get the first touch point
        const touch = e.touches[0];
        
        // Calculate the touch's X coordinate relative to the canvas
        // This is crucial for responsive canvas elements
        const touchX = (touch.clientX - rect.left) * (canvas.width / rect.width);

        // Move player based on which half of the screen was touched
        if (touchX < canvas.width / 2) {
            movePlayer('left');
        } else {
            movePlayer('right');
        }
    }, { passive: true }); // Use passive for better scroll performance

    // Button event listeners
    document.getElementById("startBtn").addEventListener("click", startGame);
    document.getElementById("pauseBtn").addEventListener("click", pauseGame);
    document.getElementById("resetBtn").addEventListener("click", resetGame);
     
    // Initial draw
    drawRoad();
    drawPlayer();
  </script>
</body>
</html>